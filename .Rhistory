ylab("Posterior Density") +
theme_classic()
# Summary
samples$summary()
# Now we need to scale it up to all possible rates and noises
recovery_df <- NULL
for (noiseLvl in unique(d$noise)) {
for (rateLvl in unique(d$rate)) {
dd <- d %>% subset(
noise == noiseLvl  & rate == rateLvl
)
data <- list(
n = 120,
h = dd$choice
)
samples <- mod$sample(
data = data,
seed = 123,
chains = 1,
parallel_chains = 1,
threads_per_chain = 1,
iter_warmup = 1000,
iter_sampling = 2000,
refresh = 0,
max_treedepth = 20,
adapt_delta = 0.99,
)
draws_df <- as_draws_df(samples$draws())
temp <- tibble(biasEst = inv_logit_scaled(draws_df$theta),
biasTrue = rateLvl, noise = noiseLvl)
if (exists("recovery_df")) {recovery_df <- rbind(recovery_df, temp)} else {recovery_df <- temp}
}
}
write_csv(recovery_df, "simdata/W3_recoverydf_simple.csv")
recovery_df <- read_csv("simdata/W3_recoverydf_simple.csv")
ggplot(recovery_df,
aes(biasTrue,
biasEst)) +
geom_point(alpha = 0.1) +
geom_smooth() +
facet_wrap(.~noise) +
theme_classic()
View(recovery_df)
# install/load packages
pacman::p_load(tidyverse,
here,
posterior,
cmdstanr,
brms,
tidybayes,
future,
purrr,
furrr)
# THE SAME BUT PARALLELIZED
plan(multisession, workers = 4)
sim_d_and_fit <- function(seed, trials, rateLvl, noiseLvl) {
for (t in seq(trials)) { # looping through trials (to make it homologous to more reactive models)
randomChoice[t] <- RandomAgentNoise_f(rateLvl, noiseLvl)
}
temp <- tibble(trial = seq(trials),
choice = randomChoice,
rate,
noise)
data <- list(
n = 120,
h = temp$choice
)
samples <- mod$sample(
data = data,
seed = 1000,
chains = 1,
parallel_chains = 1,
threads_per_chain = 1,
iter_warmup = 1000,
iter_sampling = 2000,
refresh = 0,
max_treedepth = 20,
adapt_delta = 0.99,
)
draws_df <- as_draws_df(samples$draws())
temp <- tibble(biasEst = inv_logit_scaled(draws_df$theta),
biasTrue = rateLvl,
noise = noiseLvl)
return(temp)
}
temp <- tibble(unique(d[,c("rate", "noise")])) %>%
mutate(seed = 1000,
trials = 120) %>%
rename(rateLvl = rate,
noiseLvl = noise)
recovery_df <- future_pmap_dfr(temp,
sim_d_and_fit,
.options = furrr_options(seed = TRUE))
write_csv(recovery_df, "simdata/W3_recoverydf_parallel.csv")
recovery_df <- read_csv("simdata/W3_recoverydf_parallel.csv")
ggplot(recovery_df,
aes(biasTrue,
biasEst)) +
geom_point(alpha = 0.1) +
geom_smooth() +
facet_wrap(.~noise) +
theme_classic()
# We subset to only include no noise and a specific rate
d1 <- d %>%
subset(noise == 0 & rate == 0.8) %>%
rename(Other = choice) %>%
mutate(cumulativerate = lag(cumulativerate, 1))
View(d1)
d1$cumulativerate[1] <- 0.5 # no prior info at first trial
d1$cumulativerate[d1$cumulativerate == 0] <- 0.01
d1$cumulativerate[d1$cumulativerate == 1] <- 0.99
# We subset to only include no noise and a specific rate
d1 <- d %>%
subset(noise == 0 & rate == 0.8) %>%
rename(Other = choice) %>%
mutate(cumulativerate = lag(cumulativerate, 1))
d1$cumulativerate[1] <- 0.5 # no prior info at first trial
View(d1)
d1$cumulativerate[d1$cumulativerate == 0] <- 0.01
d1$cumulativerate[d1$cumulativerate == 1] <- 0.99
# Now we create the memory agent with a coefficient of 0.9
MemoryAgent_f <- function(bias, beta, cumulativerate){
choice = rbinom(1, 1, inv_logit_scaled(bias + beta * cumulativerate))
return(choice)
}
d1$Self[1] <- RandomAgentNoise_f(0.5, 0)
for (i in 2:trials) {
d1$Self[i] <- MemoryAgent_f(bias = 0, beta = 0.8, d1$cumulativerate[i])
}
## Create the data
data <- list(
n = 120,
h = d1$Self,
memory = d1$cumulativerate # this creates the new parameter: the rate of right hands so far in log-odds
)
stan_model <- "
// The input (data) for the model. n of trials and h for (right and left) hand
data {
int<lower=1> n;
array[n] int h;
vector[n] memory; // here we add the new parameter. N.B. Log odds
}
// The parameters accepted by the model.
parameters {
real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)?
real beta; // how strongly is previous rate impacting the decision?
}
// The model to be estimated.
model {
// priors
target += normal_lpdf(bias | 0, .3);
target += normal_lpdf(beta | 0, .5);
// model
target += bernoulli_logit_lpmf(h | bias + beta * logit(memory));
}
"
write_stan_file(
stan_model,
dir = "stan/",
basename = "W3_MemoryBernoulli.stan")
## Specify where the model is
file <- file.path("stan/W3_MemoryBernoulli.stan")
mod <- cmdstan_model(file,
cpp_options = list(stan_threads = TRUE),
stanc_options = list("O1"))
# The following command calls Stan with specific options.
samples <- mod$sample(
data = data,
seed = 123,
chains = 2,
parallel_chains = 2,
threads_per_chain = 2,
iter_warmup = 1000,
iter_sampling = 1000,
refresh = 0,
output_dir = "simmodels",
max_treedepth = 20,
adapt_delta = 0.99,
)
# Same the fitted model
samples$save_object("simmodels/W3_MemoryBernoulli.rds")
samples <- readRDS("simmodels/W3_MemoryBernoulli.rds")
# Diagnostics
samples$cmdstan_diagnose()
# Extract posterior samples and include sampling of the prior:
draws_df <- as_draws_df(samples$draws())
ggplot(draws_df,
aes(.iteration,
bias,
group = .chain,
color = .chain)) +
geom_line() +
theme_classic()
ggplot(draws_df,
aes(.iteration,
beta,
group = .chain,
color = .chain)) +
geom_line() +
theme_classic()
# add a prior for theta (ugly, but we'll do better soon)
draws_df <- draws_df %>% mutate(
bias_prior = rnorm(nrow(draws_df), 0, .3),
beta_prior = rnorm(nrow(draws_df), 0, .5),
)
# Now let's plot the density for theta (prior and posterior)
ggplot(draws_df) +
geom_density(aes(bias),
fill = "blue",
alpha = 0.3) +
geom_density(aes(bias_prior),
fill = "red",
alpha = 0.3) +
geom_vline(xintercept = 0,
linetype = "dashed",
color = "black",
linewidth = 1.5) +
xlab("Bias") +
ylab("Posterior Density") +
theme_classic()
ggplot(draws_df) +
geom_density(aes(beta),
fill = "blue",
alpha = 0.3) +
geom_density(aes(beta_prior),
fill = "red",
alpha = 0.3) +
geom_vline(xintercept = 0.8,
linetype = "dashed",
color = "black",
linewidth = 1.5) +
xlab("Beta") +
ylab("Posterior Density") +
theme_classic()
samples$summary()
knitr::opts_chunk$set(echo = TRUE)
# install/load packages
pacman::p_load(tidyverse,
here,
posterior,
cmdstanr,
brms,
tidybayes,
future,
purrr,
furrr)
# DATA SIMULATION FOR RANDOM AGENT WITH NOISE
trials <- 120
# function for random agent with bias + noise
RandomAgentNoise_f <- function(rate, noise) {
# generating noiseless choices
choice <- rbinom(1, 1, rate)
# introducing noise
if (rbinom(1, 1, noise) == 1) {
choice = rbinom(1, 1, 0.5)
}
return(choice)
}
# initialize empty dataframe to receive simulation results
d <- NULL
# looping through noise levels
for (noise in seq(0, 0.5, 0.1)) {
# looping through rate levels
for (rate in seq(0, 1, 0.1)) {
randomChoice <- rep(NA, trials)
# looping through trials (to make it homologous to more reactive models)
for (t in seq(trials)) {
randomChoice[t] <- RandomAgentNoise_f(rate, noise)
}
# temporary df  to store trial number, choice, rate, noise level and
# cumulative rate for each trial
temp <- tibble(trial = seq(trials),
choice = randomChoice,
rate,
noise)
temp$cumulativerate <- cumsum(temp$choice) / seq_along(temp$choice)
# append contents of temporary df to existing df
if (exists("d")) {
d <- rbind(d, temp)
} else{
d <- temp
}
}
}
# save simulation output
write_csv(d, "simdata/W3_randomnoise.csv")
# Now we visualize it
p1 <- ggplot(d, aes(trial,
cumulativerate,
group = rate,
color = rate)) +
geom_line() +
geom_hline(yintercept = 0.5,
linetype = "dashed") +
ylim(0,1) +
facet_wrap(.~noise) +
theme_classic()
p1
# We subset to only include no noise and a specific rate
d1 <- d %>%
subset(noise == 0 & rate == 0.8) %>%
rename(Other = choice) %>%
mutate(cumulativerate = lag(cumulativerate, 1))
d1$cumulativerate[1] <- 0.5 # no prior info at first trial
d1$cumulativerate[d1$cumulativerate == 0] <- 0.01
d1$cumulativerate[d1$cumulativerate == 1] <- 0.99
# Now we create the memory agent with a coefficient of 0.9
MemoryAgent_f <- function(bias, beta, cumulativerate){
choice = rbinom(1, 1, inv_logit_scaled(bias + beta * cumulativerate))
return(choice)
}
d1$Self[1] <- RandomAgentNoise_f(0.5, 0)
for (i in 2:trials) {
d1$Self[i] <- MemoryAgent_f(bias = 0, beta = 0.8, d1$cumulativerate[i])
}
## Create the data
data <- list(
n = 120,
h = d1$Self,
memory = d1$cumulativerate # this creates the new parameter: the rate of right hands so far in log-odds
)
## Create the data
data <- list(
n = 120,
h = d1$Self,
other = d1$Other
)
stan_model <- "
// The input (data) for the model. n of trials and h for (right and left) hand
data {
int<lower=1> n;
array[n] int h;
array[n] int other;
}
// The parameters accepted by the model.
parameters {
real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)?
real beta; // how strongly is previous rate impacting the decision?
}
transformed parameters{
vector[n] memory;
for (trial in 1:n){
if (trial == 1) {
memory[trial] = 0.5;
}
if (trial < n){
memory[trial + 1] = memory[trial] + ((other[trial] - memory[trial]) / trial);
if (memory[trial + 1] == 0){memory[trial + 1] = 0.01;}
if (memory[trial + 1] == 1){memory[trial + 1] = 0.99;}
}
}
}
// The model to be estimated.
model {
// Priors
target += normal_lpdf(bias | 0, .3);
target += normal_lpdf(beta | 0, .5);
// Model, looping to keep track of memory
for (trial in 1:n) {
target += bernoulli_logit_lpmf(h[trial] | bias + beta * logit(memory[trial]));
}
}
"
write_stan_file(
stan_model,
dir = "stan/",
basename = "W3_InternalMemory.stan")
## Specify where the model is
file <- file.path("stan/W3_InternalMemory.stan")
mod <- cmdstan_model(file,
cpp_options = list(stan_threads = TRUE),
stanc_options = list("O1"))
# The following command calls Stan with specific options.
samples <- mod$sample(
data = data,
seed = 123,
chains = 1,
parallel_chains = 2,
threads_per_chain = 2,
iter_warmup = 1000,
iter_sampling = 1000,
refresh = 0,
max_treedepth = 20,
adapt_delta = 0.99,
)
samples$summary()
stan_model <- "
// The input (data) for the model. n of trials and h for (right and left) hand
data {
int<lower=1> n;
array[n] int h;
array[n] int other;
}
// The parameters accepted by the model.
parameters {
real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)?
real beta; // how strongly is previous rate impacting the decision?
real<lower=0, upper=1> forgetting;
}
// The model to be estimated.
model {
vector[n] memory;
// Priors
target += beta_lpdf(forgetting | 1, 1);
target += normal_lpdf(bias | 0, .3);
target += normal_lpdf(beta | 0, .5);
// Model, looping to keep track of memory
for (trial in 1:n) {
if (trial == 1) {
memory[trial] = 0.5;
}
target += bernoulli_logit_lpmf(h[trial] | bias + beta * logit(memory[trial]));
if (trial < n){
memory[trial + 1] = (1 - forgetting) * memory[trial] + forgetting * other[trial];
if (memory[trial + 1] == 0){memory[trial + 1] = 0.01;}
if (memory[trial + 1] == 1){memory[trial + 1] = 0.99;}
}
}
}
"
write_stan_file(
stan_model,
dir = "stan/",
basename = "W3_InternalMemory2.stan")
## Specify where the model is
file <- file.path("stan/W3_InternalMemory2.stan")
mod <- cmdstan_model(file,
cpp_options = list(stan_threads = TRUE),
stanc_options = list("O1"))
# The following command calls Stan with specific options.
samples <- mod$sample(
data = data,
seed = 123,
chains = 1,
parallel_chains = 2,
threads_per_chain = 2,
iter_warmup = 1000,
iter_sampling = 1000,
refresh = 0,
max_treedepth = 20,
adapt_delta = 0.99,
)
pacman::p_load(tidyverse, rstan)
trials <- 120
rate <- 0.5
# now as a function
RandomAgent_f <- function(input, rate){
n <- length(input)
choice <- rbinom(n, 1, rate)
return(choice)
}
trials <- 120
rate <- 0.5
# now as a function
RandomAgent_f <- function(input, rate){
n <- length(input)
choice <- rbinom(n, 1, rate)
return(choice)
}
# Building function for asymmetric win stay loose shift agent by including probabilities for winning and loosing
AsymWSLSAgent_f <- function(prevChoice, Feedback, winProb, lossProb){
if (Feedback == 1){
randomness <- rbinom(1, 1, winProb)
# stay with choice agent would initially have made
if (randomness == 1){
choice = prevChoice
# randomly shift
} else if (randomness == 0){
choice = 1-prevChoice
}
} else if (Feedback == 0){
randomness <- rbinom(1, 1, lossProb)
# stay with choice agent would initially have made
if (randomness == 1){
choice = 1-prevChoice
# randomly shift
} else if (randomness == 0){
choice = prevChoice
}
}
return(choice)
}
# empty vectors for agents
Self <- rep(NA, trials)
Random <- rep(NA, trials)
Feedbacklist <- rep(NA, trials)
# other agent's choices
for (t in seq(trials)){
Random[t] <- RandomAgent_f(trials, rate)
}
# first choice is random...
Self[1] <- rbinom(1,1,0.5)
# all other choices
for (t in 2:trials){
# get feedback
if (Self[t-1] == Random[t-1]){
Feedback = 1
} else {Feedback = 0}
# register feedback
Feedbacklist[t] <- Feedback
# make decision
Self[t] <- AsymWSLSAgent_f(Self[t-1],
Feedback,
0.9, #Win probability
0.7) #Loose probability
}
# turn into tibble
WSLS_df <- tibble(Self,
Random,
trial = seq(trials),
Feedback_prevT = Feedbacklist)
hist(rbeta(1000, 1, 1))
